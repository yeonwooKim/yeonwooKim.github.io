---
layout: post
title:  "테스트 코드와 커버리지"
author: 김연우
date: '2024-06-08'
thumbnail: /assets/img/posts/testcode.png
keywords: 테스트
---

회사마다 그리고 팀마다 테스트 코드에 대한 생각과 정책은 다 다를 것이다. 어떤 것이 정답이라고 하긴 어렵지만, 많은 개발 서적에서 테스트 코드 작성을 선택이 아닌 필수라고 이야기하고, 요즘 개발자 양성 캠프에서는 테스트 코드 작성에 대한 교육도 하는것으로 보아 그 중요도에 대해서는 어느정도 공감대가 이루어진것 같다. 토스뱅크에서도 팀마다 정책이 다르겠지만 우리 팀에서는 주요 프로젝트들에 대해 테스트 커버리지 100%를 유지하고 있다. ([토스 슬래시](https://www.youtube.com/watch?v=jdlBu2vFv58&t=412s)에 나온 그 팀이 우리 팀이다)

### 커버리지 100%의 장점
테스트 커버리지 100%는 정말 대단한 일이다. 테스트를 하지 않는 코드보다 안정성이 월등히 뛰어나다는 것은 누구도 부정할 수 없을 것이다. 때로는 100%라는 기준이 과하고 이를 달성하기 위해 불필요한 수정이나 노력을 해야하는 경우도 생긴다. 영상에서 소개된 바이트 코드 테스트가 그런 것이다. 하지만 명확한 기준이 없다면 조금만 테스트하기 까다로운 상황을 만나도 “이건 테스트하기 어렵고 하지 않아도 돼” 라고 생각해버리기 쉽기 때문에 기준을 높고 명확하게 잡아두는 것은 분명히 도움이 된다.

그 밖에도 영상에서 가볍게 소개되었지만 난 테스트와 요구사항의 관계에 대해 좀 더 강조해서 얘기하고 싶다. 개발자로서 개발자의 주요 역량 중 하나는 요구사항을 이해하는 것이라고 생각한다. 대부분의 경우 회사에서 하게 되는 개발은 엄청난 알고리즘을 생각해내는 일이 아니다 (왠지 많은 비개발자분들이 이렇게 생각하실 수도 있을 것 같은데 전혀 아니다). 내가 생각했을 때 개발자가 하게 되는 일은 크게 두가지다.

1. 디버깅하기
2. 요구사항 쫓아가기

집중하고 싶은 부분은 **요구사항 쫓아가기**다. 난 여기서 “쫓아가기”라는 표현을 썼는데 여기엔 이유가 있다. 요구사항은 항상 변한다. 새로 생기기도 하고, 기존 요구사항이 고객과의 피드백 과정에서 변경되기도 하며, 고객의 수가 늘어남에 따라 시스템 요구사항이 증가하기도 한다. 개발자로서 우리의 역할은 이렇게 바뀌는 요구사항을 시스템에 신속하게 그리고 안정적으로 반영하는 것이다. 이러한 요구사항은 99.9%의 경우에 알고리즘적으로 복잡한 요구사항은 아니다. 대신 많은 경우 (전부가 아니라면) 요구사항은 도메인 specific하며, 도메인에 대한 이해가 필수로 요구된다.

하나의 예를 들어 설명해보자면, 토스뱅크에 입사해서 처음으로 맡게 된 일들 중 하나는 “잔액 대사”였다. 이는 토스뱅크에서 지급한 금액과 결제원에 입금된 금액이 올바른지를 확인하는 과정으로 매일 일정한 시간에 배치 작업으로 실행된다. 단순하게 생각하면 이 배치가 하는 일은 정말 간단하다.

```
val yesterdayBalance = getBalanceFromYesterday()
val in = ???
val out = ???
val todayBalance = yesterdayBalance + in - out
mci.send(balance) // 계정계 계산된 잔액을 보내면 계정계에서 이 결과가 실제 회계 원장과 맞는지 확인한다
```

논리적으로 복잡한 부분은 하나도 없다. 하지만 구현하기 위해선 대사 대상이 되는 입금 금액과 지급 금액이 무엇인지 알아야하며, 은행을 둘러싼 여러 주체들(결제원, 한국은행)과 은행이 어떤식으로 상호작용을 하는지 이해해야 한다. 더 나아가서 잔액 대사란 작업이 왜 필요한지, 이 작업을 함으로써 달성하고 싶은건 무엇인지를 알아야한다. 결국 개발자가 하는 일이란건 이러한 요구사항과 도메인을 이해하고, 이를 적절하게 코드로 나타내는 작업이다. 또한 변화하는 요구사항에 맞춰 유연하게 변경 가능한 코드를 작성하는 것이다.

테스트 코드를 작성하는 것은 내가 해당 feature의 요구사항을 제대로 이해했는지 검증할 수 있는 좋은 방법이다. 영상에서 응준님도 말씀하셨듯 스스로 이해하지 못한 코드는 테스트할 수 없기 때문이다. 뿐만 아니라 테스트 코드는 테스트하고자 하는 코드가 어떻게 동작해야 한다 (should be)를 명시하기 때문에, 이후에 다른 사람이 어떤 코드의 배경이 된 요구사항을 이해하는데에도 크게 도움이 된다. 실제로 내가 잔액대사 배치를 작성할때 다른 대사 배치의 테스트 코드를 읽어서 specification을 파악했다. 뿐만 아니라 다른 프로젝트의 코드베이스를 파악하는데 있어서도 코드 자체를 읽는거보다 테스트 코드를 읽는것이 해당 코드의 전체적인 동작을 이해하는데 도움이 많이 된다고 느꼈다.

### 커버리지 100%의 단점? TDD는 어떤지?
이미 커버리지가 100%인 프로젝트에서 100%를 유지하는 것은 상대적으로 어렵지 않을 것이다. 하지만 그마저도 응준님이 슬래시에서 소개했듯이 바이트 코드 테스팅, 테스트 코드 최적화 등 테스트 자체를 위해 시간을 많이 쓰게 된다는 단점이 있다. 이외에도 단순히 커버리지를 채우기 위한 테스트도 작성할 수밖에 없게 되고, 또 테스트를 위해 원래 코드를 고치는 등 어떻게 보면 주객전도의 상황도 많이 생긴다.

또, “커버리지가 100%면 리팩토링에 자신감이 생긴다”라는 말에는 솔직히 크게 공감하지 못한다. Instruction level 테스트 커버리지 100%라는 것의 정확한 의미는 “테스트를 실행하면 모든 instruction이 적어도 한번씩 실행된다”이지 각 instruction이 맞는 행동을 하는지를 검증한다는 의미가 아니다. 따라서 테스트 커버리지가 100%라고 버그가 없는 것은 절대 아니며, 오히려 100%이더라도 테스트가 잡지 못하는 버그가 훨씬 많다고 생각한다. 그리고 유닛 테스트의 함정은 리팩토링을 하면 대부분의 경우에 테스트도 고치게 된다는 것이다. 따라서 리팩토링으로 테스트 코드에도 버그가 생길 수 있으며, 이러한 위험성은 테스트 커버리지를 높이는 것으로 크게 줄어들지는 않는다고 생각한다.

그래도 이미 100%라면 100%를 유지하는 것은 좋은 전략이라고 생각한다. 하지만 100%가 아닌 프로젝트라면 어떨까? 이미 작성되어 있는 코드에 유닛 테스트를 잔뜩 추가해서 100%를 만드는건 시간대비 얼마나 효용이 있을까? 나는 이에 대해서도 조금 회의적이다. 코드를 작성한지 한참 된 시점에서 해당 코드에 유닛 테스트를 작성하면 코드에 테스트를 끼워맞추는 경향성이 매우 강해진다. 이는 TDD(Test Driven Development)를 하지 않는 이상은 어느정도 늘 있는 문제이지만, 코드를 작성한 시점과 테스트를 작성하게 되는 시점 사이의 기간이 길면 길수록 심하다. 결국 명세가 되어야 하는 테스트 코드가 단순히 현재 코드가 어떻게 동작하는지를 기술하는 코드로 전락하기 때문에 크게 의미가 없다는 생각이 들었다.

그렇다면 무조건 TDD를 도입하는 것이 좋은걸까? 나는 사실 TDD를 하는 팀에 소속되어 일해본적이 없어서 이에 대해 뭐라고 정확히 말하기가 힘들다. 하지만 개인적으로는 역시 조금 현실성이 떨어진다는 느낌이 있다. 특히 애자일한 development cycle에서 TDD는 도입 난이도가 더욱 올라간다. 왜냐면 요구사항이 전부 확정되지 않은채로 개발에 들어가고, 프로토타입을 빠르게 공유한 다음 **피드백을 통해 요구사항을 다듬어가는** 경우가 많기 때문이다. 이 때문에 TDD를 하게 되면 테스트 코드를 자주 수정해야해서 필요하지 않은 공수가 더 들어갈지도 모른다는 걱정이 앞선다. 하지만 이건 경험해보지 않아서 뭐라고 얘기하기가 어렵고, 오히려 애자일 조직에서 TDD가 빛을 발한다고 주장하는 책들도 많다. 나도 한번쯤 TDD를 채택하는 팀에서 일해보고 싶다는 생각이 있다.

### 내가 생각하는 좋은 테스트
**커리어 스킬**이란 책에서 최근에 회귀 테스트(Regression Testing)라는 말을 배웠다. 버그가 발견되었을때 이를 해결하면서 버그가 있을때는 실패하고 고치면서 해결되는 테스트를 추가하는 것이다. 나는 이러한 방식이 정말 자연스럽고 실용적인 테스트 방식이라고 느꼈다. 완벽하게 버그없는 프로그램을 만들기는 어렵지만 확실하게 이미 생겼던 버그의 재발을 막으며, 자연스럽게 취약한 부분의 커버리지를 높일 수 있게 되기 때문이다.

최근에 일하면서 몇가지 회귀 테스트를 넣었다. 그 중 하나는 `배치 실행 테스트`다. 정말 단순하게 스프링 컨텍스트를 로드하고, 테스트 배치가 정상실행되는지를 확인하는 테스트이다. (아래 같은 느낌의 테스트)

```
@SpringBootTest
fun BatchApplicationTest() {
  fun `어플리케이션이 실행되고 배치가 돈다`() {
    val testBatch = TestBatch()
    testBatch.run()
  }
}
```

넣게 된 이유는 최근에 연달아서 배치가 안뜨는 상태로 어플리케이션이 개발서버에 배포되어 실서버가 오류에 노출될 위기가 있었기 때문이다. 다행히 개발서버에 배포된 이후 e2e 테스트에서 배치가 안뜬다는 에러 리폿을 받긴 했지만, 때로는 개발서버의 에러로그를 살펴볼 시간 없이 실서버에 배포하게 될 수도 있기에 정말 위험한 상황이라고 생각했다.

그래서 PR 머지 전에 배치가 정상적으로 뜨는지를 확인하기 위해 배치 실행 테스트를 추가하고, 배치가 안떴던 커밋에서 해당 테스트가 실패하는것과 수정 후에 통과하는것을 확인했다. 팀원분들도 좋아해주셨고, 동의를 얻어 여러 프로젝트에 적용해보기로 했다.

슬래시 속 응준님의 말씀처럼 베스트는 테스트를 밀린 숙제처럼 작성할 필요 없게 늘 코드와 테스트를 같이 작성해나가는 것이라고 생각한다. 하지만 정말 급한 일정 때문에 테스트 코드를 작성할 수 없는 경우도 종종 생기기 마련이다. 그럴때는 한번에 유닛테스트를 전부 작성해서 추가하려 하기 보다는, 앞으로 작성하는 코드에 테스트를 함께 작성하고, 해당 서비스에 버그가 생길때마다 회귀 테스트를 하나씩 더해나가다 보면, 100%는 아닐지라도 훨씬 안정적이고 커버리지도 우수한 서비스를 만들어나갈 수 있을거라고 믿는다.
