코루틴은 코틀린을 배우기 시작하면서 가장 어려운 동시에 재밌다고 느껴졌던 기술(혹은 패러다임)이다. 혹시 이 글을 읽는 분들 중에 코틀린을 시작하려고 하는 개발자 분들이 있다면 “코틀린 코루틴” 책을 적극 추천한다. 반복해서 읽으면 코루틴에 대한 근본적인 이해도를 높일 수 있다. 나도 한달 동안 두번을 읽었는데, 확실히 첫번째 읽을때보다 두번째 읽을때에 명확해지는 부분이 많아서 좋았다. 여전히 코루틴에 대해 뭔가를 안다고 말하기 어려운 수준이지만, 최대한 내가 이해한 내용을 이 글에 정리해보려고 한다.

### 코루틴과 중단함수
책 전체에 걸쳐서 가장 많이 나오는 두개의 말은 단연 **코루틴**과 **중단함수**이다. 하지만 놀랍게도 1회 독때 나는 책을 완독하고 나서도 이 두개가 무엇이고 어떻게 다른지를 정확히 알지 못했다. 알고 나면 명확히 다른 개념이지만, 이해하기 전까지 많은 사람들이 혼동할 수 있는 개념이라고 생각한다.

중단함수는 말 그대로 중단 가능한 함수를 말한다. 중단함수에는 `suspend` 키워드가 앞에 붙으며, 다른 중단 함수나 코루틴 빌더(이후에 설명)에서만 사용할 수 있다. 보통은 중단함수 내의 실제 중단을 구현하게 될 일은 잘 없다. 중단함수는 많은 경우 데이터베이스나 네트워크 클라이언트 라이브러리에서 구현해서 제공되며, 개발할때는 단순히 라이브러리에 정의된 중단함수를 호출하는 정도로 사용된다.

코루틴은 이러한 중단함수가 실행되는 단위이다. 간단하게 얘기하면 중단 함수는 함수 그 자체인 반면, 코루틴은 함수 호출을 의미한다고도 얘기할 수 있을것 같다. 따라서 중단 함수에는 함수 자체 로직과 중단 포인트에 대한 정보만 있을 뿐이지만, 중단 함수를 호출하는 코루틴에는 이 함수가 어느 쓰레드 풀에서 호출될지, 어떤 맥락(CoroutineContext)을 가지고 있는지 등의 정보가 들어있다. 코루틴은 코루틴 빌더 함수에 의해서 생성된다.

코루틴 빌더는  `async`, `launch`, `runBlocking` 등이 있다. 각각이 전부 조금씩 다르지만, 모두 실행할 중단함수를 인자로 받는다는 공통점이 있다. 아래 예제 코드를 보자.

```
fun main() {
  runBlocking {
    helloWorld()
  }
}

suspend fun helloWorld() {
  delay(1000) // built-in 중단함수
  println("Hello World!")
}
```

예제를 보면, `runBlocking` 코루틴 빌더에 의해 `helloWorld` 중단 함수는 실행된다(반대로 얘기하면 중단 함수는 코루틴 빌더에 의해서만 실행될 수 있다). 실행된 중단함수는 built-in 중단함수인 `delay`를 부르고, delay는 내부적으로 1000ms동안 실행을 중단한다.

이 부분이 다시 좀 난해해지는 부분이라고 생각한다. 중단 함수의 nesting을 모두 없애고 spread했을 때 어떤 코드가 되는지를 보면 이해에 도움이 된다.

```
fun main() {
  private val executor = ... // Executor
  runBlocking {
    suspendCoroutine { cont ->
      executor.schedule({
        cont.resume(Unit)
      }, timeMillis, TimeUnit.MILLISECONDS)
    }
    println("Hello World!")
  }
}
```

위에 코드를 보면 `delay` 함수는 결국 내부적으로 `suspendCoroutine` 이라는 코틀린 내장 함수를 써서 중단을 구현하고 있는 것을 알 수 있다. 우리가 쓰는 어떠한 중단 함수도 다 끝까지 아래로 내려가면 이렇게 `suspendCoroutine` 을 사용해서 중단과 재개시점을 구현하고 있다. 그런데 `suspendCoroutine`은 그러면 어떻게 동작하는 걸까? 욕심을 조금 더 내서 한번 더 위 코드를 풀어헤쳐보자.

```
fun main() {
  private val executor = ... // Executor
  runBlocking { cont ->
    if (cont.label == BEFORE_DELAY) {
      cont.label = AFTER_DELAY
      executor.schedule({
        // call this method again suspend_fun(cont)
      }, timeMillis, TimeUnit.MILLISECONDS)
      return
    } else {
      println("Hello World!")
    }
  }
}
```

위 pseudo-code는 정확한 코드는 아니며 내 이해를 바탕으로 `suspendCoroutine`을 풀어본 것이다. 코드를 보면 라벨을 바탕으로 분기하고 있으며 첫 실행때 라벨을 바꾸고 다음 실행을 호출하고 리턴한다. 이어서 호출된 다음 실행에서 다른 분기를 통해 실제 로직을 호출한다.

중단함수가 어떻게 nesting이 되는지까지 들어가면 복잡해지지만 실제 중단 함수는 이런식으로 중단 가능한 포인트마다 상태를 가지고 분기하도록 구현되어있다. nesting을 위해서는 위 코드에 있는 cont 객체를 nested call마다 decorating하면서 넘겨주면 된다.

여기까지 중단함수와 코루틴에 대해 정리해봤다. 추가로 조금 덧붙이자면, 코루틴 빌더는 중단함수를 호출하지만, 중단함수 내에서는 코루틴 빌더를 호출할 수 없다. 중단 함수 내에서 새로운 코루틴을 실행하기 위해서는 스코프 함수를 통해서 스코프를 새로 정의하고, 코루틴 빌더를 사용하여 코루틴을 실행해야 한다. 따라서 전체 코루틴을 사용하는 스킴은 아래 그림과 같다.

<img src="{{ site.url }}{{ site.baseurl }}/assets/images/coroutine.png" alt="">

### Reactor와의 차이
이전 회사에서는 리액터 기반의 Spring Webflux를 주로 사용했었다. 그래서 난 처음에는 리액터를 어느정도 이해하고 있으니까 같은 비동기 프로그래밍 기술인 코루틴을 이해하는데에도 별 무리가 없을 것이라고 생각했다. 이 생각은 반은 맞고 반은 틀린거 같다.

리액터의 Mono, Flux와 코루틴은 아예 다른 개념이다. 가장 큰 차이점은 Mono는 차갑다. Mono를 정의하는 행위는 함수를 정의하는것과 비슷하여 어떠한 결과는 만들지 않는다. 그런 의미에서 Reactor의 Mono와 Flux는 둘다 코루틴의 cold stream인 Flow와 대응되고, 실제로 리액터 스택에 익숙한 사람들이 하나의 값을 리턴하는 경우에도 중단 함수가 아닌 Flow를 사용해 구현한다고 한다 (책에서는 이를 권장하지는 않는다).

여기서부턴 개인적인 의견이다. 코루틴과 리액터 모두 비동기 프로그래밍에 많이 사용되는 기술이지만 나는 두 기술이 전혀 다른곳에 집중하고 있다는 생각이 들었다. 리액터는 Reactive Streams의 구현체로 기본적으로 비동기 **스트리밍**에 매우 중점을 두고 있는 스택이다. 그래서 리액터는 비동기 실행보다는 상대적으로 무한의 스트림 데이터를 어떤식으로 주고 받을지에 집중한다. 반면 코루틴은 비동기로 프로그램을 실행하는데에 중점을 많이 두고 있는 스택이라고 느꼈다. 비동기 프로그래밍을 할때 어떤식으로 실행, 완료, 실패, 취소될지를 조금 더 쉽게 모델링할 수 있는 기술이라고 생각한다.

이 글은 “코틀린 코루틴” 책에 나오는 내용을 바탕으로 작성한 글이다. 혹시 이보다 더 깊은 내용을 알고 싶다면 책을 읽어보기를 강력 추천한다. 글에서는 다루지 못하는 Channel과 Flow, 그리고 코루틴 스코프에 대한 더 깊이 있는 내용을 자세히 알아볼 수 있다.


