---
layout: post
title:  "MSA와 API 호출"
author: 김연우
date: '2024-06-30'
thumbnail: /assets/img/posts/microservice.jpeg
keywords: MSA, 아키텍쳐
---

오늘은 이번주에 회사 일을 하다가 다루게 된 특정 문제에 대해 정리해보고자 한다.

## MSA vs Monolithic
그 전에 토스뱅크의 시스템 구조를 다시 한번 정리하자면, 토스뱅크의 은행시스템은 크게 MSA(Micro-Service Architecture)로 구성된 채널계와 Monolithic으로 구성된 계정계로 이루어져있다. 채널계는 다양한 서비스 로직을 담고 있으며, 클라이언트와 직접 소통한다. 그리고 계정계의 도움이 필요한 핵심 로직에 대해서 계정계에 요청한다.

예를 들어, “송금”이라는 기능을 수행하기 위해, 채널계는 클라이언트(토스 앱)로부터 필요한 정보를 받아서 송금 전 필요한 사전 검증 및 사용자 설정 확인(e.g. 지연 송금 기능) 등을 거치고, 실제 송금은 계정계에 요청하여 수행한다. 이후 계정계의 응답을 받아서 다시 에러 처리를 채널계에서 수행하는 식이다. 은행 시스템은 왜 이렇게 구성되어 있을까? 이걸 이해하기 위해서는 MSA와 Monolithic의 차이를 이해해야 한다. MSA와 Monolithic Architecture의 차이는 면접 단골 출제 질문이고 검색해보면 여러가지 차이점들을 알 수 있지만, 여기서는 내가 토스뱅크에 와서 느낀 둘의 차이점을 얘기해보려고 한다.

### 관리의 용이성
은행 시스템의 도메인은 정말 넓고 복잡하다. 우리 팀만 해도 자동납부, 자동이체, 지로, 송금, 오픈뱅킹 등 다양한 주제를 다루고 있지만, 이는 은행 전체로 보면 정말 일부분에 불과하다. 이외에도 수신 상품, 여신 상품, 카드, 채권 등등 정말 다양한 주제들을 다른 팀들에서 다루고 있다. 그런데 이런 주제들이 하나의 거대한 서버에 혼재해 있다면 어떨까? 팀 별로 어디서부터 어디까지가 우리의 관리 영역인지 알기 힘들고, 나처럼 신입이 왔을때 업무를 파악하는데까지 훨씬 많은 시간이 걸릴것이다.

또한, 토스뱅크는 현재 채널계 서버들을 굉장히 자주 배포하고 최신상태로 유지하고 있는데, 이게 여러개의 작은 서버가 아닌 거대한 하나의 서버였다면, 이렇게 자주 배포하기 힘들어질 것이다. 그러면 결국 하나의 거대한 업데이트 단위를 둬서 배포를 수행하게 되고, 전통 금융권처럼 down time을 가질 수 밖에 없게 된다. 토스뱅크가 잠들지 않는 은행이 될 수 있었던건 바로 채널계가 MSA로 구성되어 있기 때문이라고 생각한다.

### 영향도 분리
이건 사실 어느정도는 위의 내용이랑도 이어지는데, 채널계의 서비스는 개발 속도가 매우 빠르며 자주 라이브에 반영된다. 이는 어느정도의 리스크를 감수하고 생산성을 높이려는 토스 특유의 전략이다. 그러다 보면 새로운 피쳐를 개발한 후에 실서버에 반영했을때 장애가 나기도 하는데, 다행인건 이러한 장애가 토스뱅크 시스템 전체에 영향을 미치지 않는다는 것이다.

예를 들어, 우리 팀이 관리하는 서버 중 지로라는 서버가 나의 실수로 장애가 났다고 가정해보자. 이는 지로에 의존성이 있는 다른 서비스에 영향을 줄 수도 있지만, 지로와는 전혀 상관없는 여신 서버 등에 장애를 전파하지는 않는다. 반대로 내가 새로운 피쳐를 실서비스에 반영하는 과정에서 전체 은행 시스템이 영향을 받는다면 배포 부담이 지금보다 엄청나게 커질 것이다.

### 일관성 보장
그렇다면 계정계 시스템은 왜 Monolithic을 채택하고 있을까? 단일 서버로 이루어진 시스템은 그만의 장점을 가지고 있다. 그 중 내가 제일 중요하다고 생각하는 장점은 바로 **일관성**이다. 은행은 실제 돈을 다루는 시스템인만큼 데이터 일관성(또는 정합성)이 굉장히 중요하다. 송금 과정에서 시스템의 실수로 출금계좌에서는 돈이 빠졌으나 입금처에 제대로 입금되지 않는다는 등의 문제가 있으면 안된다는 의미이다. 다른 식으로 표현하면 은행의 Transaction에 대해 ACID를 보장해야한다는 뜻이 된다.

데이터 정합성은 MSA 구조에서는 보장하기 매우 어렵다. 하나의 Transaction에 관련되어 있는 마이크로서비스가 다섯개라고 생각해보자. 정합성을 보장하기 위해서 이중 하나의 서비스라도 트랜잭션 처리에 실패한다면 모든 과정은 롤백되어야 한다. 그러기 위해서는 각각의 결과가 성공했는지 실패했는지를 응답으로 받아야하고, 실패했을때 기존 동작과 반대되는 동작을 수행하도록 서비스들을 Orchestration해야 한다. 관련된 패턴으로는 SAGA 패턴 등이 있는데, 이건 지금 다루지는 않겠다. 

그에 반해 Monolithic 서버는 모든 동작이 하나의 서버에서 이루어지기 때문에 데이터 정합성을 보장하기 상대적으로 쉽다. 그렇기 때문에 MSA의 모든 장점을 제쳐두고서라도 은행의 핵심로직을 계정계라는 거대한 단일 서버에 유지하게 되는 것이다.

## 문제
이번주에 내가 겪었던 문제는, MSA 환경에서의 API 과호출 문제이다. 우리 송금 서버는 토스뱅크의 계좌정보를 담고 있는 별도 서버에 계좌 관련 정보 (계좌 종류, 소유주.. 등등)를 얻기 위해 API 호출을 하고 있는데, 문제는 이 횟수가 좀 과도하게 많다는 것이다. 내가 직접 실험해봤을때 우리 서버는 계좌 정보 서버에 1회 송금에 6번의 호출을 하고 있는 것으로 보였다. 만약 계좌 정보 서비스와 송금 서비스가 단일 서비스로 구성되어 있었다면 이는 큰 문제가 아닐 수 있지만, HTTP API 호출은 추가적인 네트워크 오버헤드를 가지고 있기 때문에 서로 다른 서버간의 API 과호출은 CPU, 메모리, 네트워크 등의 자원 낭비로 이어진다.

이러한 문제의 연장선에서, 마이크로서비스간 정보 교환에 있어서 API 호출을 무분별하게 사용하면 이러한 API 호출이 loop을 형성해서 응답시간 지연, 리소스 낭비 등의 문제로 이어지기도 한다. 따라서 서로 다른 팀이 각기 다른 마이크로서비스를 운용하고 있다고 해서 다른 서비스의 동작에 대해 무관심해서는 안된다. 자원 낭비를 줄이고 MSA를 효율적으로 운용하기 위해서는 어떤 워크플로우가 전체 시스템 상에서 어떤식으로 흐르는지를 정확하게 이해하고 만들어야한다고 생각한다.

계좌정보 중에는 유동적인 정보도 있지만, 개설 이후 바뀔 일이 없는 정보가 더 많다. 계좌의 소유주, 개설일자, 계좌 종류 등이 그러한 정보이다. 이런 정보들은 outdated 되지 않기 때문에 캐싱하기에 용이하다. 송금 서버에서는 기존에도 계좌정보를 캐싱하고 있었지만, 데이터 일관성을 위해 캐싱 시간을 1초로 제한했다. 변할 일이 없는 필드에 한해서 캐싱 시간에 제약을 두지 않는다면 캐시 효율을 극대화할 수 있지 않을까? 이 부분에 대해 이번주에 정리했고, 추가로 팀원들과 논의를 거쳐 적용해보고자 한다.

하나의 트랜잭션을 처리하는데에 있어 하나의 서버를 두번 이상 방문하는것은 보편적으로 봤을때 낭비라고 볼 수 있다. 모듈화라든지 다른 장점들을 취하기 위해 이러한 부분을 감안하는것은 있을 수 있는 일이지만, 적어도 이러한 낭비가 있다는것을 인지하는 것은 선택이 아닌 필수라는 생각이 들었다. 모니터링에 있어서도 하나의 트레이스 안에서 마이크로서비스들 사이를 어떻게 traverse 하는지를 모니터링할 수 있게 개선하면 더 좋을것 같다.
