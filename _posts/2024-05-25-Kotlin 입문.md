이직이 결정되고 쉬는동안 나는 토스뱅크에서 사용하고 있는 스택 중에 내가 모르는 스택을 공부하는데에 주로 힘썼다. (누군가는 이직할때는 그냥 쉬는거다 모르는건 가서 배워도 된다 할 수도 있는데, 나는 모르는 스택을 미리 공부해가는걸 추천한다. 일에 적응하면서 스택까지 익히기란 쉽지 않다.) 그중 하나는 **코틀린**이었다. 이전 직장에서는 자바를 주로 썼기 때문에 이직 결정 당시 나는 코틀린을 아예 쓸 줄 몰랐다.

주로는 언어를 그냥 써보면서 주먹구구식으로 배워왔으나, 시간 여유도 있겠다 이번엔 언어를 좀 제대로 써보자 하는 생각에 아래 세개의 코틀린 책을 구매해서 읽어봤다.

* Kotlin in Action
* Effective Kotlin
* Kotlin Coroutines

책을 읽어본 후기로는, 언어를 배울때 관련 책을 읽어보는것을 강력 추천하고 나도 앞으로 새로운 언어를 배울때 무조건 책을 한두권은 읽어보게 될 것 같다. 물론 언어를 그냥 사용하는건 Quick Start 가이드를 보거나 아니면 다른 사람이 짠 코드부터 보면서 기본적인 명령어들의 문법을 파악해도 충분하지만, 언어만의 특징을 이해하고 좀 더 그 언어가 만들어진 의도대로 예쁘게 사용하기 위해서는 책을 읽어보는게 확실히 도움이 된다고 느꼈다.

위에 적은 세가지의 책들 중에서 나는 특히 Kotlin in Action을 아주 재미있게 읽었다. 누군가 코틀린을 배워보고자 한다면 이 책을 반드시 추천할 것이고, 나 또한 이 책을 반복해서 읽을 의향이 있을 정도로 코틀린에 담긴 의도가 명확하게 잘 표현된 책이라고 생각한다. 벌써 책을 읽은지는 한달 정도 지나서 많은 것들을 이미 잊어버렸지만 내가 인상깊다고 생각했던 코틀린의 특징들을 정리해보자면 아래와 같다.

### 확장 함수와 수신객체 지정 람다
확장 함수(Extension Function)는 코틀린의 가장 크고 독특한 특징이라고 생각한다. 확장 함수란, 어떤 클래스의 정의를 고치지 않고 해당 클래스에 새로운 메서드를 정의하는 (정확히는 정의한듯 사용할 수 있는) 코틀린의 문법이다. 확장 함수를 정의해서 사용하면 코틀린에서는 클래스 내부에 정의된 메소드와 똑같은 방식으로 사용할 수 있다. 내부적으로는 해당 클래스 객체를 첫번째 인자로 받는 유틸 클래스의 static method로 컴파일 된다. 예시를 보자.

```
class Dog {
	fun bark() {
		println("Bark!")
	}
}

// 1. Extension Function
fun Dog.barkThreeTimes() {
	println("Bark Bark Bark!")
}

// 2. Actually
class DogUtil {
	companion object {
		fun barkThreeTimes(Dog dog) {
		}
	}
}

val dog = Dog()
dog.bark() // Bark!
dog.barkThreeTimes() // Bark Bark Bark!
DogUtil.barkThreeTimes(dog)
```

위 예제를 보면 `bark`는 클래스 내부에 정의된 메소드고, `barkThreeTimes`는 `Dog` 클래스의 확장 함수다. 호출하는 문법은 둘이 차이가 없는 것을 확인할 수 있다. 하지만 이는 내부적으로는 `DogUtil`에 정의된 `barkThreeTimes` 와 비슷하게 컴파일된다. 결국 새로운 기능을 제공하는 것이 아니고, 기존에 자바에서 static한 utility method를 정의하는 것과 기능은 동일하나 이를 메소드와 똑같은 방식으로 호출할 수 있게 syntactic sugar를 제공하는 것이라고 이해할 수 있다.

수신 객체 지정 람다(Lambda with Receiver)는 단순히 위에서 본 확장함수의 개념을 람다에 적용했다고 이해할 수 있다. 마찬가지로 예시를 보자.

```
val printStr = { str: String -> println(str) }
val print: String.() -> Unit = { println(this) }

printStr("Hi mom!")
"Hi mom!".print()
```

위 예제에서 `print`는 `String` 클래스의 객체를 수신 객체로 하는 수신객체 지정 람다이다. 확장함수와 마찬가지로 내부적으로는 `printStr`과 다를바가 없으나, 코틀린은 이러한 문법적인 편의를 람다에 대해서도 제공하고 있다.

여기서부터는 확장함수와 수신객체 지정 람다에 대한 개인적인 의견을 얘기하고자 한다. 이 두가지가 만들어내는 코틀린의 가장 큰 특징은 **자연스러운 코드**라고 생각한다. 자바와 비교해서 얘기를 해보자면 (참고로 난 자바를 싫어하지 않는다), 자바에서는 어떤 라이브러리에서 정의하는 클래스 객체를 쓰다가 기능을 추가하고자 할때, 위의 `DogUtil` 예제처럼 static method로 이를 해결해야한다. 이는 외부 라이브러리와 내부 구현 간 호출 문법의 차이로 코드에 나타난다.

반면 코틀린에서는 확장함수를 이용해 해당 클래스의 기능을 확장할 수 있기 때문에, 마치 그 라이브러리에 정의돼있는 것처럼 함수를 정의하고 사용할 수 있다. 실제로 코틀린 표준 라이브러리가 제공하는 많은 함수들이 확장함수로 정의돼있다고 한다. 이는 코드를 글의 일종이라고 봤을때, 내부 정의냐 외부 정의냐와 같은 불필요한 정보 없이 자연스러운 글의 흐름을 유지할 수 있게 한다.

### 강화된 타입 검증
코틀린을 공부하기 전부터 코틀린이 null check를 강화한 언어라는 것은 알고 있었다. 그만큼 코틀린 사용자들이 극찬하는 기능 중에 하나가 nullable 타입의 도입이다. 자바를 사용할때 NPE (Null Pointer Exception)에 고통받은 경험은 다들 굉장히 많이 있을 것이다. 나도 지금 당장 내 이전 회사의 깃헙 레포에 NPE를 검색해본다면 수십개가 나올 것이라고 자신한다.

책을 읽으면서 알게 된것은 코틀린 타입시스템이 자바 타입시스템과 비교해 단순한 nullable 타입 도입 이상의 개선이 있었다는 점이다. 굉장히 많지만 기억 나는 것들 위주로 정리해본다.

#### MutableCollection 타입 도입
개인적으로 가장 마음에 드는 변화 중 하나이다. MutableCollection은 Immutable한 값 타입들과는 본질적으로 다르다. 예를 들면,

```
val str: String = "Hi mom!"
val list: MutableList<String> = arrayListOf<String>()

str = "Hi mom again!" // error
list.add(str) // no error
```

`list.add` 호출은 에러를 내지 않고 `list`를 변화시킨다. 이는 우리가 `list`를 `final`로 선언했음에도 값이 변하지 않음을 보장할 수 없다는 뜻이다. 불변성은 아주 중요한 성질이다. 어떤 객체에 대해서 우리가 모르는 어떤 side effect가 일어나지 않음을 보장해주기 때문에 버그 가능성을 낮추고 코드 안정성을 향상시킨다. 특히 병렬화에 있어서 불변성은 아주 중요하다. 값이 변하지 않을때 여러 쓰레드가 안전하게 같은 리소스에 접근할 수 있기 때문이다.

물론 언어적인 차원에서 지원해주지 않아도 프로그래머들끼리 앉아서 약속을 할 수는 있다. 하지만 이러한 약속은 깨지기 마련이며 깨진 불변성은 곳곳에서 예기치 못한 버그로 나타나곤 한다. 코틀린은 MutableCollection과 Collection을 분리하면서 이를 언어적으로 보장해주고자 노력했다. 물론 Java Collection 기반이기 때문에 이러한 노력이 아직 완벽하진 않고 깨질 여지가 있지만, 의미 있는 개선점이라는 생각이 들었다.

#### Covariance, Contravariance 개념 도입
코틀린은 공변성 / 반공변성이라는 성질을 도입해 타입 계층을 좀 더 세밀하게 실현한다. 자세하게는 글이 너무 길어져서 다루지 않겠으나, 기존 자바 타입시스템의 불완전한 점들을 많이 개선하고, 현실 요구사항을 반영하여 안정성과 기능 확장 모두를 잘 이루어냈다고 생각한다.

이외에도 많은 특징들이 있으나 자세한 내용은 Kotlin in Action 책을 읽어볼것을 강력하게 권한다! 개인적으로 나는 코틀린이라는 언어가 현대적인 요구사항에 맞게 잘 만들어진 언어라고 느꼈다. 확장 함수와 같은 문법 뿐 아니라 함수형 프로그래밍을 강력하게 지원하는 면 또한 굉장히 매력적으로 느껴졌고, 회사 일과 별개로 앞으로 코틀린을 주력 언어로 사용할 수 있게 계속 공부해보고자 한다. 또, 코루틴에 대해서는 하고 싶은 말이 많아서 따로 글을 쓰겠다.